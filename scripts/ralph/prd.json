{
  "project": "treb-cli",
  "branchName": "ralph/fork-mode",
  "description": "Fork Mode - Per-chain global mode for testing deployment scripts against local long-running forks of live networks with snapshot/revert workflow",
  "userStories": [
    {
      "id": "US-001",
      "title": "Fork state domain model and persistence",
      "description": "As a developer, I need a ForkState domain model and file persistence so that fork mode state survives across CLI invocations.",
      "acceptanceCriteria": [
        "Define ForkState struct in internal/domain/ containing a map of active forks keyed by network name",
        "Each ForkEntry tracks: network name, chain ID, env var name, original RPC URL, fork URL (localhost + port), anvil PID, PID file path, log file path, entered-at timestamp",
        "Each ForkEntry contains a SnapshotStack (slice of SnapshotEntry with: index, evm snapshot ID, command string, timestamp)",
        "Define ForkStateStore interface in internal/usecase/ports.go with Load/Save/Delete methods",
        "Implement ForkStateStore adapter in internal/adapters/fs/ that reads/writes .treb/priv/fork-state.json",
        "Provide IsForkActive(network string) bool and GetActiveFork(network string) (*ForkEntry, error) helper methods on ForkState",
        "State file created on first Save, directory .treb/priv/ created if needed",
        "Unit tests for ForkState serialization/deserialization round-trip",
        "Unit tests for IsForkActive and GetActiveFork",
        "Lint passes",
        "Unit tests pass"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Anvil manager fork support and snapshot RPC methods",
      "description": "As a developer, I need the anvil manager extended with --fork-url support and evm_snapshot/evm_revert RPC methods.",
      "acceptanceCriteria": [
        "Extend AnvilInstance domain model (internal/domain/anvil.go) with optional ForkURL field",
        "In anvil manager Start method (internal/adapters/anvil/manager.go), add --fork-url <url> to anvil args when ForkURL is set",
        "Add TakeSnapshot(instance *AnvilInstance) (string, error) method that calls evm_snapshot JSON-RPC on the instance URL and returns the snapshot ID",
        "Add RevertSnapshot(instance *AnvilInstance, snapshotID string) error method that calls evm_revert JSON-RPC",
        "Add snapshot/revert methods to the AnvilManager interface in internal/usecase/ports.go",
        "PID files for fork instances use /tmp/treb-fork-<name>.pid naming, log files use /tmp/treb-fork-<name>.log",
        "Unit tests for arg building with and without ForkURL",
        "Lint passes",
        "Unit tests pass"
      ],
      "priority": 2,
      "passes": true,
      "notes": "The test framework (test/helpers/test_context.go) already has takeSnapshot/revertSnapshot helper functions using the same RPC calls - reference those for implementation patterns."
    },
    {
      "id": "US-003",
      "title": "File backup and restore utility",
      "description": "As a developer, I need a utility to backup and restore all .treb/ registry files for the snapshot stack.",
      "acceptanceCriteria": [
        "Create a ForkFileManager (or similar) in internal/adapters/fs/ with BackupFiles and RestoreFiles methods",
        "BackupFiles(projectRoot string, network string, snapshotIndex int) copies these files from .treb/ to .treb/priv/fork/<network>/snapshots/<N>/: deployments.json, transactions.json, safe-txs.json, registry.json, addressbook.json",
        "RestoreFiles(projectRoot string, network string, snapshotIndex int) copies files back from the snapshot directory to .treb/, overwriting current state",
        "CleanupForkDir(projectRoot string, network string) removes the entire .treb/priv/fork/<network>/ directory",
        "Handle missing source files gracefully (skip files that don't exist rather than error)",
        "Define interface in internal/usecase/ports.go",
        "Unit tests using temp directories for backup/restore round-trip",
        "Lint passes",
        "Unit tests pass"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Files to backup: deployments.json, transactions.json, safe-txs.json, registry.json, addressbook.json. All live in .treb/ at the project root."
    },
    {
      "id": "US-004",
      "title": "Detect and migrate RPC endpoint env var format",
      "description": "As a developer, I want treb to detect whether a foundry.toml RPC endpoint uses ${VAR} expansion and offer migration if not.",
      "acceptanceCriteria": [
        "Add a function to parse raw (unexpanded) RPC endpoint value from foundry.toml for a given network name",
        "The current loadFoundryConfig in internal/config/foundry.go expands env vars immediately - add a method or field that preserves the raw TOML value before expansion",
        "DetectEnvVar(rawValue string) returns (envVarName string, isEnvVar bool) - extracts VAR_NAME from ${VAR_NAME} patterns",
        "GenerateEnvVarName(networkName string) returns the convention name: uppercase, dashes to underscores, append _RPC_URL (e.g. celo-sepolia -> CELO_SEPOLIA_RPC_URL)",
        "MigrateRPCEndpoint(projectRoot, networkName, rawURL string) updates foundry.toml to replace the hardcoded URL with ${<GENERATED_NAME>} and appends <GENERATED_NAME>=<rawURL> to .env",
        "Unit tests for DetectEnvVar with various patterns: ${VAR}, hardcoded URL, ${VAR}/path, empty",
        "Unit tests for GenerateEnvVarName with network names: sepolia, celo-sepolia, anvil-31337",
        "Lint passes",
        "Unit tests pass"
      ],
      "priority": 4,
      "passes": true,
      "notes": "The foundry.toml is parsed via BurntSushi/toml in internal/config/foundry.go. RPC endpoints are under [rpc_endpoints] section. The migration modifies foundry.toml inline (just the one RPC entry) and appends to .env."
    },
    {
      "id": "US-005",
      "title": "Fork enter command",
      "description": "As a developer, I want treb fork enter <network> to start a forked anvil, backup registry files, and prepare fork mode.",
      "acceptanceCriteria": [
        "New cobra command group: treb fork with subcommand enter, registered in internal/cli/",
        "treb fork enter <network> requires network as positional argument",
        "Resolves network's real RPC URL from foundry.toml (after env var expansion)",
        "Checks RPC endpoint format - if hardcoded URL, prompts user to migrate (see US-004). Aborts if user declines.",
        "Extracts the env var name from the ${VAR} pattern for later override",
        "Finds available port via net.Listen('tcp', '127.0.0.1:0')",
        "Starts anvil with --fork-url <real_rpc_url> --port <port> --chain-id <chain_id> using extended anvil manager",
        "Waits for anvil health check (RPC responsive)",
        "Deploys CreateX to the fork (reuses existing anvil manager logic)",
        "Backs up all .treb/ registry files to .treb/priv/fork/<network>/snapshots/0/ using ForkFileManager",
        "Takes initial EVM snapshot via anvil manager, records as snapshot stack base (index 0)",
        "Saves ForkEntry to fork state file",
        "Prints status: network, chain ID, fork URL, anvil PID",
        "Errors if fork already active for this network",
        "Adds .treb/priv/ to .gitignore if not already present",
        "Create use case in internal/usecase/enter_fork.go",
        "Integration test: treb fork enter anvil-31337 succeeds — fork state file exists at .treb/priv/fork-state.json, registry files backed up to .treb/priv/fork/anvil-31337/snapshots/0/, anvil fork process is running and healthy",
        "Integration test: treb fork enter on an already-forked network errors with appropriate message",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Wire the use case using the existing DI pattern in internal/app/. Reference treb dev anvil start for anvil lifecycle patterns. Port allocation pattern is in test/helpers/test_context.go getAvailablePort(). Integration tests go in test/integration/fork_test.go using the existing framework."
    },
    {
      "id": "US-006",
      "title": "Fork exit command",
      "description": "As a developer, I want treb fork exit to stop the forked anvil, restore registry files, and clean up all fork state.",
      "acceptanceCriteria": [
        "New subcommand: treb fork exit [network]",
        "If network omitted, uses current configured network from .treb/config.local.json",
        "Stops the anvil fork process via anvil manager (SIGTERM then SIGKILL)",
        "Restores all .treb/ registry files from initial backup (snapshot 0) using ForkFileManager",
        "Removes fork directory .treb/priv/fork/<network>/ including all snapshots",
        "Removes fork entry from fork state file",
        "If no more active forks, deletes fork-state.json entirely",
        "Prints summary: network exited, number of fork deployments discarded",
        "Errors if no fork active for the specified network",
        "treb fork exit --all exits all active forks (iterates and exits each)",
        "Handles already-dead anvil processes gracefully (clean up state even if PID is gone)",
        "Create use case in internal/usecase/exit_fork.go",
        "Integration test: fork enter → fork exit restores original .treb/deployments.json, cleans up .treb/priv/fork/<network>/, anvil process is stopped",
        "Integration test: fork enter → treb run (deploys contract) → fork exit restores registry to pre-fork state (deployed contract no longer in deployments.json)",
        "Integration test: fork exit with no active fork errors appropriately",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "RPC override in forge adapter for fork mode",
      "description": "As a developer, I want treb run to automatically inject the fork RPC URL into the forge process environment when fork mode is active.",
      "acceptanceCriteria": [
        "In forge adapter's buildEnv() (internal/adapters/forge/forge.go), accept fork state or check for active fork for the current network",
        "If fork is active, add env var override: <ENV_VAR_NAME>=http://localhost:<fork_port> to the command environment",
        "The override is added to the forge subprocess env only (cmd.Env), not written to .env or modified in parent process",
        "The --rpc-url flag in buildArgs() continues to pass the network name (unchanged)",
        "This ensures vm.rpcUrl('<network>') and vm.createFork('<network>') inside Solidity scripts resolve to the fork URL via foundry.toml -> ${ENV_VAR} -> overridden value",
        "The fork state must be accessible from the forge adapter - either passed through RunScriptConfig or looked up from the state file",
        "Integration test: fork enter → treb run DeployCounter → contract deployed to fork anvil (verify via eth_getCode on fork URL), deployment recorded in .treb/deployments.json with the forked chain's chain ID",
        "Integration test: treb run without fork mode deploys to regular anvil (not fork) — confirms override only applies when fork is active",
        "Unit tests: buildEnv includes override when fork is active for the network",
        "Unit tests: buildEnv does NOT include override when no fork is active",
        "Unit tests: buildEnv does NOT include override when fork is active for a different network",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 7,
      "passes": true,
      "notes": "The forge adapter currently builds env with: FOUNDRY_PROFILE, NAMESPACE, NETWORK, DRYRUN, SENDER_CONFIGS, plus user params. The fork override is just one more entry. The key insight: forge resolves --rpc-url <name> via foundry.toml [rpc_endpoints] which contains ${VAR}, and we override that VAR in the subprocess env."
    },
    {
      "id": "US-008",
      "title": "Pre-run EVM and file snapshots in fork mode",
      "description": "As a developer, I want each treb run in fork mode to automatically take EVM and file snapshots before execution.",
      "acceptanceCriteria": [
        "In the RunScript use case (internal/usecase/run_script.go), detect if fork mode is active for the current network",
        "If active, before executing forge script: take EVM snapshot via anvil manager and backup all .treb/ files to the next snapshot index",
        "Record the snapshot in the fork state's snapshot stack: index, evm snapshot ID, command (script path + args), timestamp",
        "Save updated fork state to disk",
        "If the forge script execution fails, the snapshot is preserved (don't clean it up - user may want to inspect or revert)",
        "After successful execution, registry files are updated as normal (they're in .treb/ which is the active state)",
        "The snapshot index increments monotonically within a fork session",
        "Integration test: fork enter → treb run DeployCounter → verify snapshot 1 directory exists at .treb/priv/fork/<network>/snapshots/1/ with pre-run registry files, fork-state.json has 2 entries in snapshot stack (initial + pre-run)",
        "Integration test: fork enter → treb run Script1 → treb run Script2 → verify snapshots 1 and 2 exist, fork-state.json has 3 entries in snapshot stack",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 8,
      "passes": true,
      "notes": "The RunScript use case already has the hook point after parameter resolution and before forge execution. Insert the snapshot logic there."
    },
    {
      "id": "US-009",
      "title": "Fork revert command",
      "description": "As a developer, I want treb fork revert to undo the last treb run by restoring EVM state and registry files.",
      "acceptanceCriteria": [
        "New subcommand: treb fork revert",
        "Pops the top entry from the snapshot stack (must not be index 0 - that's the initial state)",
        "Calls evm_revert(<snapshot_id>) on the fork anvil to restore EVM state",
        "Restores all .treb/ files from the popped snapshot's directory",
        "Removes the snapshot directory after restore",
        "Updates fork state file with the modified snapshot stack",
        "Prints: what command was reverted, how many snapshots remain",
        "If only initial snapshot (index 0) remains, error with 'Nothing to revert - already at initial fork state'",
        "treb fork revert --all: reverts to initial state by reverting EVM to snapshot 0's ID and restoring files from snapshot 0, clears all other snapshots",
        "Note: Anvil's evm_revert consumes the target snapshot but preserves older ones, so the stack model works naturally",
        "Create use case in internal/usecase/revert_fork.go",
        "Integration test: fork enter → treb run DeployCounter → fork revert → Counter no longer in deployments.json, contract no longer at predicted address on fork (eth_getCode returns 0x), snapshot stack back to just initial entry",
        "Integration test: fork enter → treb run DeployCounter → treb run DeployToken → fork revert → Token reverted but Counter still deployed and in registry",
        "Integration test: fork enter → treb run → treb run → fork revert --all → both reverted, registry matches initial backup, only initial snapshot remains",
        "Integration test: fork enter (no runs) → fork revert → error 'Nothing to revert'",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 9,
      "passes": true,
      "notes": "After evm_revert to an older snapshot, all newer Anvil snapshots are automatically invalidated. The stack-based model matches this behavior exactly."
    },
    {
      "id": "US-010",
      "title": "SetupFork script config and execution on fork enter",
      "description": "As a developer, I want treb fork enter to run a configured SetupFork script after starting the fork to prepare state.",
      "acceptanceCriteria": [
        "Add fork.setup key to local config model (internal/domain/config/local.go) for storing the setup script path",
        "Support treb config set fork.setup <path> to configure the setup script (e.g. script/SetupFork.s.sol)",
        "On treb fork enter, after anvil is healthy and CreateX deployed, check if fork.setup is configured",
        "If configured and the script file exists, execute it via forge script with the fork's RPC env var override active",
        "SetupFork runs with the default profile's sender configuration",
        "If SetupFork fails, abort fork enter: stop anvil, clean up state files, print error",
        "The initial EVM snapshot and file backup (snapshot 0) are taken AFTER SetupFork completes",
        "If fork.setup not configured or file doesn't exist, skip silently",
        "A single SetupFork script handles all networks - it branches on block.chainid internally",
        "Integration test: configure fork.setup to a test SetupFork script that calls vm.deal to give an address ETH → fork enter → verify the address has the expected balance on the fork",
        "Integration test: configure fork.setup to a script that reverts → fork enter fails, anvil is stopped, no fork state file created",
        "Integration test: fork enter with no fork.setup configured succeeds normally (no setup script run)",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 10,
      "passes": true,
      "notes": "The SetupFork script is a regular forge script that can use anvil_impersonateAccount, vm.deal, vm.store etc. Common use case: convert Safe to 1/1 ownership for fork testing. The treb-sol ForkHelper (US-018) provides utilities for this."
    },
    {
      "id": "US-011",
      "title": "Fork status command",
      "description": "As a developer, I want treb fork status to show the state of all active forks.",
      "acceptanceCriteria": [
        "New subcommand: treb fork status",
        "Shows all active forks in a table with: network name, chain ID, fork URL, anvil PID, uptime (since entered-at), snapshot count",
        "Indicates which fork corresponds to the currently configured network (from .treb/config.local.json)",
        "Health-checks each fork's anvil process (PID alive + RPC responsive) and shows healthy/dead status",
        "Shows fork-added deployment count by comparing current .treb/deployments.json against initial backup",
        "If no forks active, prints 'No active forks'",
        "Add render function in internal/cli/render/ for fork status output",
        "Integration test: fork enter → fork status shows fork with healthy status, 0 fork deployments, 1 snapshot",
        "Integration test: fork enter → treb run → fork status shows 1 fork deployment, 2 snapshots",
        "Integration test: no active forks → fork status shows 'No active forks'",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 11,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "Fork history command",
      "description": "As a developer, I want treb fork history to show commands run against a fork and their snapshot points.",
      "acceptanceCriteria": [
        "New subcommand: treb fork history [network]",
        "If network omitted, uses current configured network",
        "Shows chronological list of snapshot stack entries: index, command, timestamp",
        "Marks the current top of stack (most recent, next to be reverted)",
        "Marks index 0 as 'initial' (the fork enter point)",
        "If no fork active for the network, error with message",
        "Add render function in internal/cli/render/ for fork history output",
        "Integration test: fork enter → treb run DeployCounter → treb run DeployToken → fork history shows 3 entries (initial, DeployCounter, DeployToken) with DeployToken marked as current",
        "Integration test: fork enter → treb run → fork revert → fork history shows only initial entry",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 12,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "Fork-aware list display",
      "description": "As a developer, I want treb list to visually distinguish fork-added deployments from pre-fork ones.",
      "acceptanceCriteria": [
        "When fork mode is active for the current network, treb list shows all deployments from .treb/deployments.json as normal",
        "Fork-added deployments (IDs not present in initial backup at .treb/priv/fork/<network>/snapshots/0/deployments.json) are marked with a [fork] indicator",
        "Add --fork flag to treb list that filters to show only fork-added deployments",
        "Add --no-fork flag to treb list that filters to show only pre-fork deployments",
        "JSON output (--json) includes a fork: true field on fork-added entries",
        "If no fork is active, flags are no-ops and no fork indicators shown",
        "Update render functions in internal/cli/render/ for the fork indicator",
        "Integration test: deploy Counter before fork → fork enter → deploy Token in fork → treb list shows Counter (no indicator) and Token with [fork] indicator",
        "Integration test: same setup → treb list --fork shows only Token",
        "Integration test: same setup → treb list --no-fork shows only Counter",
        "Integration test: same setup → treb list --json includes fork: true on Token, fork field absent or false on Counter",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 13,
      "passes": true,
      "notes": "To determine fork-added entries: load deployments.json from snapshot 0, diff deployment IDs against current deployments.json. Any ID in current but not in snapshot 0 is fork-added."
    },
    {
      "id": "US-014",
      "title": "Fork-aware show command",
      "description": "As a developer, I want treb show to indicate when a deployment was added during fork mode.",
      "acceptanceCriteria": [
        "When fork mode is active and the shown deployment is fork-added (not in initial backup), display [fork] indicator in the output header",
        "treb show works as normal otherwise - files are in-place, no special lookup needed",
        "Add --no-fork flag that skips fork-added deployments (only resolves from pre-fork entries)",
        "Update render functions in internal/cli/render/ for the fork indicator",
        "Integration test: fork enter → deploy Counter → treb show Counter displays [fork] indicator",
        "Integration test: deploy Counter before fork → fork enter → treb show Counter does NOT display [fork] indicator",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 14,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-015",
      "title": "Anvil crash detection and fork restart command",
      "description": "As a developer, I want treb to detect crashed fork anvil processes and provide recovery options.",
      "acceptanceCriteria": [
        "Before each treb run in fork mode, health-check the fork's anvil (PID alive + RPC responsive via anvil manager)",
        "If anvil is dead, print error: 'Fork anvil for <network> has crashed. EVM snapshots are no longer valid.'",
        "Suggest: treb fork restart <network> or treb fork exit <network>",
        "Do NOT auto-restart (snapshots are lost, registry may be out of sync)",
        "New subcommand: treb fork restart [network] - stops dead process if needed, restores files from initial backup (snapshot 0), starts fresh fork, re-runs SetupFork if configured, takes new initial snapshot",
        "treb fork status shows 'dead' status for crashed forks",
        "treb fork exit of a crashed fork cleans up state files even though anvil is already dead",
        "Create use case in internal/usecase/restart_fork.go",
        "Integration test: fork enter → kill anvil process (SIGKILL) → treb run → error message about crashed fork with suggested commands",
        "Integration test: fork enter → treb run DeployCounter → kill anvil → treb fork restart → fresh fork running, registry restored to initial state, Counter no longer in deployments.json",
        "Integration test: fork enter → kill anvil → treb fork status shows 'dead' status",
        "Integration test: fork enter → kill anvil → treb fork exit succeeds, cleans up state files",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 15,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-016",
      "title": "Command guards for fork-incompatible operations",
      "description": "As a developer, I want fork-incompatible commands to be blocked with clear error messages.",
      "acceptanceCriteria": [
        "treb verify in fork mode: error with 'Cannot verify contracts on a fork'",
        "treb sync in fork mode: error with 'Cannot sync with a fork'",
        "Add fork mode check in the PersistentPreRunE of root command or in each command's RunE",
        "treb prune in fork mode: operates normally but prints note that it's pruning fork state",
        "treb register in fork mode: operates normally but prints note about fork state",
        "treb reset in fork mode: operates normally (resets current fork-modified registry)",
        "treb tag in fork mode: operates normally",
        "Integration test: fork enter → treb verify Counter → error 'Cannot verify contracts on a fork'",
        "Integration test: fork enter → treb sync → error 'Cannot sync with a fork'",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 16,
      "passes": true,
      "notes": "Only verify and sync are hard-blocked. Other commands operate on the current .treb/ files (which are fork-modified) with informational notes."
    },
    {
      "id": "US-017",
      "title": "Fork diff command",
      "description": "As a developer, I want treb fork diff to show what deployments were added or changed during fork mode.",
      "acceptanceCriteria": [
        "New subcommand: treb fork diff [network]",
        "If network omitted, uses current configured network",
        "Compares current .treb/deployments.json against the initial backup at .treb/priv/fork/<network>/snapshots/0/deployments.json",
        "Shows: new deployments added (IDs in current but not backup), deployments modified (same ID but different data), transactions added",
        "Output format consistent with treb list style for deployments",
        "Support --json flag for JSON output",
        "If no fork active, error with message",
        "Add render function in internal/cli/render/ for fork diff output",
        "Create use case in internal/usecase/diff_fork.go",
        "Integration test: fork enter → deploy Counter → deploy Token → fork diff shows 2 new deployments (Counter, Token)",
        "Integration test: fork enter (no runs) → fork diff shows no changes",
        "Integration test: fork enter → deploy → fork revert → fork diff shows no changes (reverted back to initial)",
        "Lint passes",
        "Unit tests pass",
        "Integration tests pass"
      ],
      "priority": 17,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-018",
      "title": "SetupFork helper contract in treb-sol",
      "description": "As a developer, I want a treb-sol helper contract that simplifies common fork setup tasks.",
      "acceptanceCriteria": [
        "New contract in treb-sol/src/ForkHelper.sol",
        "convertSafeToSingleOwner(address safe, address newOwner) function: uses vm.store to rewrite Safe storage - sets owner count to 1, threshold to 1, owner linked list to contain only newOwner. This makes the Safe act as a regular EOA for fork testing.",
        "dealNativeToken(address to, uint256 amount) function: wrapper around vm.deal(to, amount)",
        "dealERC20(address token, address to, uint256 amount) function: uses vm.store to set ERC20 balanceOf mapping. Handles common slot layouts (slot 0 and slot 1 for the balanceOf mapping, auto-detect via probing).",
        "All functions use anvil cheatcodes (vm.store, vm.deal) and require running on a local fork",
        "NatSpec documentation on each function explaining purpose and usage",
        "Helper designed to be inherited by user's SetupFork scripts: contract SetupFork is ForkHelper, TrebScript { ... }",
        "Unit tests in treb-sol/test/ verifying Safe conversion, native token deal, and ERC20 deal on a local fork",
        "forge build succeeds in treb-sol/",
        "forge test passes in treb-sol/"
      ],
      "priority": 18,
      "passes": false,
      "notes": "This is in the treb-sol submodule (Solidity, not Go). Safe storage layout: slot 2 = ownerCount, slot 3 = threshold, owners stored in a linked list mapping at slot 2. ERC20 balanceOf is typically at slot 0 or slot 1 depending on the token implementation."
    }
  ]
}
