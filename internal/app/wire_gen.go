// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/spf13/viper"
	"github.com/trebuchet-org/treb-cli/internal/adapters"
	"github.com/trebuchet-org/treb-cli/internal/adapters/anvil"
	"github.com/trebuchet-org/treb-cli/internal/adapters/blockchain"
	config2 "github.com/trebuchet-org/treb-cli/internal/adapters/config"
	"github.com/trebuchet-org/treb-cli/internal/adapters/contracts"
	"github.com/trebuchet-org/treb-cli/internal/adapters/environment"
	"github.com/trebuchet-org/treb-cli/internal/adapters/forge"
	"github.com/trebuchet-org/treb-cli/internal/adapters/fs"
	"github.com/trebuchet-org/treb-cli/internal/adapters/interactive"
	"github.com/trebuchet-org/treb-cli/internal/adapters/parameters"
	"github.com/trebuchet-org/treb-cli/internal/adapters/parser"
	"github.com/trebuchet-org/treb-cli/internal/adapters/registry"
	"github.com/trebuchet-org/treb-cli/internal/adapters/safe"
	"github.com/trebuchet-org/treb-cli/internal/adapters/template"
	"github.com/trebuchet-org/treb-cli/internal/adapters/verification"
	"github.com/trebuchet-org/treb-cli/internal/cli/render"
	"github.com/trebuchet-org/treb-cli/internal/config"
	"github.com/trebuchet-org/treb-cli/internal/usecase"
)

// Injectors from wire.go:

// InitApp creates a fully wired App instance with viper configuration
func InitApp(v *viper.Viper, sink usecase.ProgressSink) (*App, error) {
	runtimeConfig, err := config.Provider(v)
	if err != nil {
		return nil, err
	}
	selectorAdapter, err := interactive.NewSelectorAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	deploymentSelector := ProvideDeploymentSelector(selectorAdapter)
	registryStoreAdapter, err := fs.NewRegistryStoreAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	listDeployments := usecase.NewListDeployments(runtimeConfig, registryStoreAdapter, sink)
	showDeployment := usecase.NewShowDeployment(runtimeConfig, registryStoreAdapter, sink)
	string2 := adapters.ProvideProjectPath(runtimeConfig)
	indexer := contracts.NewIndexer(string2)
	contractResolver := contracts.NewContractResolver(runtimeConfig, indexer, selectorAdapter)
	abiParserAdapter, err := forge.NewABIParserAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	scriptGeneratorAdapter, err := template.NewScriptGeneratorAdapter(runtimeConfig, abiParserAdapter)
	if err != nil {
		return nil, err
	}
	fileWriterAdapter, err := fs.NewFileWriterAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	generateDeploymentScript := usecase.NewGenerateDeploymentScript(runtimeConfig, contractResolver, abiParserAdapter, scriptGeneratorAdapter, fileWriterAdapter, sink)
	networkResolver := config.ProvideNetworkResolver(runtimeConfig)
	networkResolverAdapter := config2.NewNetworkResolverAdapter(networkResolver)
	listNetworks := usecase.NewListNetworks(networkResolverAdapter)
	checkerAdapter := blockchain.NewCheckerAdapter()
	pruneRegistry := usecase.NewPruneRegistry(networkResolverAdapter, checkerAdapter, registryStoreAdapter, sink)
	localConfigStoreAdapter := fs.NewLocalConfigStoreAdapter(runtimeConfig)
	showConfig := usecase.NewShowConfig(localConfigStoreAdapter)
	setConfig := usecase.NewSetConfig(localConfigStoreAdapter)
	removeConfig := usecase.NewRemoveConfig(localConfigStoreAdapter)
	scriptResolver := contracts.NewScriptResolver(string2, contractResolver)
	parameterResolver := parameters.NewParameterResolver(runtimeConfig, registryStoreAdapter, indexer)
	scriptExecutorAdapter := forge.NewScriptExecutorAdapter(runtimeConfig)
	executionParser, err := parser.NewExecutionParser(string2)
	if err != nil {
		return nil, err
	}
	registryUpdater := registry.NewRegistryUpdater(registryStoreAdapter, registryStoreAdapter)
	builderAdapter := environment.NewBuilderAdapter(string2)
	libraryResolver := registry.NewLibraryResolver(registryStoreAdapter)
	runScript := usecase.NewRunScript(runtimeConfig, scriptResolver, parameterResolver, scriptExecutorAdapter, executionParser, registryUpdater, builderAdapter, libraryResolver, sink)
	verifierAdapter, err := verification.NewVerifierAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	verifyDeployment := usecase.NewVerifyDeployment(registryStoreAdapter, verifierAdapter, networkResolverAdapter, registryStoreAdapter)
	orchestrateDeployment := usecase.NewOrchestrateDeployment(runScript, sink)
	clientAdapter, err := safe.NewClientAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	syncRegistry := usecase.NewSyncRegistry(registryStoreAdapter, registryStoreAdapter, registryStoreAdapter, clientAdapter, sink)
	tagDeployment := usecase.NewTagDeployment(registryStoreAdapter, sink)
	manager := anvil.NewManager()
	manageAnvil := usecase.NewManageAnvil(manager, sink)
	initProject := usecase.NewInitProject(fileWriterAdapter, sink)
	renderer := render.NewGenerateRenderer()
	app, err := NewApp(runtimeConfig, deploymentSelector, listDeployments, showDeployment, generateDeploymentScript, listNetworks, pruneRegistry, showConfig, setConfig, removeConfig, runScript, verifyDeployment, orchestrateDeployment, syncRegistry, tagDeployment, manageAnvil, initProject, manager, renderer)
	if err != nil {
		return nil, err
	}
	return app, nil
}

// wire.go:

// ProvideDeploymentSelector provides DeploymentSelector interface from SelectorAdapter
func ProvideDeploymentSelector(adapter *interactive.SelectorAdapter) usecase.DeploymentSelector {
	return adapter
}
