// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/trebuchet-org/treb-cli/internal/adapters"
	"github.com/trebuchet-org/treb-cli/internal/adapters/abi"
	"github.com/trebuchet-org/treb-cli/internal/adapters/anvil"
	"github.com/trebuchet-org/treb-cli/internal/adapters/blockchain"
	"github.com/trebuchet-org/treb-cli/internal/adapters/forge"
	"github.com/trebuchet-org/treb-cli/internal/adapters/fs"
	"github.com/trebuchet-org/treb-cli/internal/adapters/progress"
	"github.com/trebuchet-org/treb-cli/internal/adapters/repository/contracts"
	"github.com/trebuchet-org/treb-cli/internal/adapters/repository/deployments"
	"github.com/trebuchet-org/treb-cli/internal/adapters/resolvers"
	"github.com/trebuchet-org/treb-cli/internal/adapters/template"
	"github.com/trebuchet-org/treb-cli/internal/adapters/verification"
	"github.com/trebuchet-org/treb-cli/internal/cli/interactive"
	"github.com/trebuchet-org/treb-cli/internal/cli/render"
	"github.com/trebuchet-org/treb-cli/internal/config"
	"github.com/trebuchet-org/treb-cli/internal/logging"
	"github.com/trebuchet-org/treb-cli/internal/usecase"
)

// Injectors from wire.go:

// InitApp creates a fully wired App instance with viper configuration
func InitApp(v *viper.Viper, cmd *cobra.Command) (*App, error) {
	runtimeConfig, err := config.Provider(v)
	if err != nil {
		return nil, err
	}
	selectorAdapter, err := interactive.NewSelectorAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	logger := logging.NewLogger(runtimeConfig)
	fileRepository, err := deployments.NewFileRepositoryFromConfig(runtimeConfig, logger)
	if err != nil {
		return nil, err
	}
	networkResolver := config.ProvideNetworkResolver(runtimeConfig)
	listDeployments := usecase.NewListDeployments(runtimeConfig, fileRepository, networkResolver)
	deploymentResolver := resolvers.NewDeploymentResolver(runtimeConfig, fileRepository, selectorAdapter)
	showDeployment := usecase.NewShowDeployment(runtimeConfig, fileRepository, deploymentResolver)
	string2 := adapters.ProvideProjectPath(runtimeConfig)
	repository := contracts.NewRepository(string2, logger)
	contractResolver := resolvers.NewContractResolver(runtimeConfig, repository, selectorAdapter)
	eventParser := abi.NewEventParser(string2, logger)
	abiResolver := abi.NewABIResolver(runtimeConfig, repository, fileRepository)
	scriptGeneratorAdapter, err := template.NewScriptGeneratorAdapter(runtimeConfig, eventParser, abiResolver)
	if err != nil {
		return nil, err
	}
	fileWriterAdapter, err := fs.NewFileWriterAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	generateDeploymentScript := usecase.NewGenerateDeploymentScript(runtimeConfig, contractResolver, eventParser, abiResolver, scriptGeneratorAdapter, fileWriterAdapter)
	listNetworks := usecase.NewListNetworks(networkResolver)
	forgeAdapter := forge.NewForgeAdapter(string2, logger)
	castTracer := adapters.ProvideCastTracer(forgeAdapter)
	checkerAdapter := blockchain.NewCheckerAdapter(castTracer, string2)
	pruner := deployments.NewPruner(fileRepository, checkerAdapter)
	spinnerProgressReporter := progress.NewSpinnerProgressReporter()
	pruneRegistry := usecase.NewPruneRegistry(networkResolver, checkerAdapter, pruner, fileRepository, spinnerProgressReporter)
	resetRegistry := usecase.NewResetRegistry(runtimeConfig, fileRepository, fileRepository)
	localConfigStoreAdapter := fs.NewLocalConfigStoreAdapter(runtimeConfig)
	showConfig := usecase.NewShowConfig(localConfigStoreAdapter)
	setConfig := usecase.NewSetConfig(localConfigStoreAdapter)
	removeConfig := usecase.NewRemoveConfig(localConfigStoreAdapter)
	scriptResolver := resolvers.NewScriptResolver(string2, contractResolver)
	parameterResolver := resolvers.NewParameterResolver(runtimeConfig, fileRepository, repository)
	sendersManager := config.NewSendersManager(runtimeConfig)
	runResultHydrator, err := forge.NewRunResultHydrator(string2, eventParser, repository, logger)
	if err != nil {
		return nil, err
	}
	libraryResolver := resolvers.NewLibraryResolver(fileRepository)
	writer := render.ProvideIO(cmd)
	scriptRenderer := render.NewScriptRenderer(writer, fileRepository, abiResolver, logger)
	runProgress := progress.NewRunProgress(scriptRenderer)
	runScript := usecase.NewRunScript(runtimeConfig, scriptResolver, parameterResolver, sendersManager, runResultHydrator, fileRepository, libraryResolver, runProgress, forgeAdapter)
	verifierAdapter, err := verification.NewVerifierAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	verifyDeployment := usecase.NewVerifyDeployment(fileRepository, verifierAdapter, networkResolver, deploymentResolver, spinnerProgressReporter)
	composeRenderer := render.NewComposeRenderer(writer)
	composeProgress := progress.NewComposeProgress(composeRenderer, scriptRenderer)
	composeDeployment := usecase.NewComposeDeployment(runScript, composeProgress)
	syncRegistry := usecase.NewSyncRegistry(runtimeConfig, fileRepository, spinnerProgressReporter)
	tagDeployment := usecase.NewTagDeployment(fileRepository, deploymentResolver, spinnerProgressReporter)
	registerDeployment := usecase.NewRegisterDeployment(runtimeConfig, fileRepository, checkerAdapter, repository)
	manager := anvil.NewManager()
	manageAnvil := usecase.NewManageAnvil(manager, spinnerProgressReporter)
	initProject := usecase.NewInitProject(fileWriterAdapter, spinnerProgressReporter)
	renderer := render.NewGenerateRenderer()
	app, err := NewApp(runtimeConfig, selectorAdapter, listDeployments, showDeployment, generateDeploymentScript, listNetworks, pruneRegistry, resetRegistry, showConfig, setConfig, removeConfig, runScript, verifyDeployment, composeDeployment, syncRegistry, tagDeployment, registerDeployment, manageAnvil, initProject, manager, renderer, scriptRenderer, composeRenderer)
	if err != nil {
		return nil, err
	}
	return app, nil
}
