// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/spf13/viper"
	"github.com/trebuchet-org/treb-cli/internal/adapters"
	"github.com/trebuchet-org/treb-cli/internal/adapters/blockchain"
	config2 "github.com/trebuchet-org/treb-cli/internal/adapters/config"
	"github.com/trebuchet-org/treb-cli/internal/adapters/contracts"
	"github.com/trebuchet-org/treb-cli/internal/adapters/environment"
	"github.com/trebuchet-org/treb-cli/internal/adapters/forge"
	"github.com/trebuchet-org/treb-cli/internal/adapters/fs"
	"github.com/trebuchet-org/treb-cli/internal/adapters/interactive"
	"github.com/trebuchet-org/treb-cli/internal/adapters/parameters"
	"github.com/trebuchet-org/treb-cli/internal/adapters/parser"
	"github.com/trebuchet-org/treb-cli/internal/adapters/progress"
	"github.com/trebuchet-org/treb-cli/internal/adapters/registry"
	"github.com/trebuchet-org/treb-cli/internal/adapters/safe"
	"github.com/trebuchet-org/treb-cli/internal/adapters/template"
	"github.com/trebuchet-org/treb-cli/internal/adapters/verification"
	"github.com/trebuchet-org/treb-cli/internal/config"
	"github.com/trebuchet-org/treb-cli/internal/usecase"
)

// Injectors from wire.go:

// InitApp creates a fully wired App instance with viper configuration
func InitApp(v *viper.Viper, sink usecase.ProgressSink) (*App, error) {
	runtimeConfig, err := config.Provider(v)
	if err != nil {
		return nil, err
	}
	selectorAdapter, err := interactive.NewSelectorAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	deploymentSelector := ProvideDeploymentSelector(selectorAdapter)
	registryStoreAdapter, err := fs.NewRegistryStoreAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	listDeployments := usecase.NewListDeployments(runtimeConfig, registryStoreAdapter, sink)
	showDeployment := usecase.NewShowDeployment(runtimeConfig, registryStoreAdapter, sink)
	contractIndexerAdapter, err := fs.NewContractIndexerAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	resolveContract := usecase.NewResolveContract(runtimeConfig, contractIndexerAdapter, selectorAdapter, sink)
	contractResolver := ProvideContractResolver(resolveContract)
	abiParserAdapter, err := forge.NewABIParserAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	scriptGeneratorAdapter, err := template.NewScriptGeneratorAdapter(runtimeConfig, abiParserAdapter)
	if err != nil {
		return nil, err
	}
	fileWriterAdapter, err := fs.NewFileWriterAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	generateDeploymentScript := usecase.NewGenerateDeploymentScript(runtimeConfig, contractResolver, abiParserAdapter, scriptGeneratorAdapter, fileWriterAdapter, sink)
	networkResolver := config.ProvideNetworkResolver(runtimeConfig)
	networkResolverAdapter := config2.NewNetworkResolverAdapter(networkResolver)
	listNetworks := usecase.NewListNetworks(networkResolverAdapter)
	checkerAdapter := blockchain.NewCheckerAdapter()
	pruneRegistry := usecase.NewPruneRegistry(networkResolverAdapter, checkerAdapter, registryStoreAdapter, sink)
	localConfigStoreAdapter := fs.NewLocalConfigStoreAdapter(runtimeConfig)
	showConfig := usecase.NewShowConfig(localConfigStoreAdapter)
	setConfig := usecase.NewSetConfig(localConfigStoreAdapter)
	removeConfig := usecase.NewRemoveConfig(localConfigStoreAdapter)
	scriptResolverAdapter, err := contracts.NewScriptResolverAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	parameterResolverAdapter := parameters.NewParameterResolverAdapter(runtimeConfig)
	parameterPrompterAdapter := parameters.NewParameterPrompterAdapter(parameterResolverAdapter)
	scriptExecutorAdapter := forge.NewScriptExecutorAdapter(runtimeConfig)
	indexer, err := adapters.ProvideContractsIndexer(runtimeConfig)
	if err != nil {
		return nil, err
	}
	executionParserAdapter := parser.NewExecutionParserAdapter(indexer)
	string2 := adapters.ProvideProjectPath(runtimeConfig)
	updaterAdapter, err := registry.NewUpdaterAdapter(string2)
	if err != nil {
		return nil, err
	}
	builderAdapter := environment.NewBuilderAdapter(string2)
	libraryResolverAdapter, err := registry.NewLibraryResolverAdapter(string2)
	if err != nil {
		return nil, err
	}
	spinnerProgressReporter := progress.NewSpinnerProgressReporter()
	runScript := usecase.NewRunScript(runtimeConfig, scriptResolverAdapter, parameterResolverAdapter, parameterPrompterAdapter, scriptExecutorAdapter, executionParserAdapter, updaterAdapter, builderAdapter, libraryResolverAdapter, spinnerProgressReporter)
	verifierAdapter, err := verification.NewVerifierAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	verifyDeployment := usecase.NewVerifyDeployment(registryStoreAdapter, verifierAdapter, networkResolverAdapter, registryStoreAdapter)
	orchestrateDeployment := usecase.NewOrchestrateDeployment(runScript, sink)
	clientAdapter, err := safe.NewClientAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	syncRegistry := usecase.NewSyncRegistry(registryStoreAdapter, registryStoreAdapter, registryStoreAdapter, clientAdapter, sink)
	tagDeployment := usecase.NewTagDeployment(registryStoreAdapter, sink)
	app, err := NewApp(runtimeConfig, deploymentSelector, listDeployments, showDeployment, generateDeploymentScript, listNetworks, pruneRegistry, showConfig, setConfig, removeConfig, runScript, verifyDeployment, orchestrateDeployment, syncRegistry, tagDeployment)
	if err != nil {
		return nil, err
	}
	return app, nil
}

// wire.go:

// ProvideContractResolver provides ContractResolver interface from ResolveContract
func ProvideContractResolver(uc *usecase.ResolveContract) usecase.ContractResolver {
	return uc
}

// ProvideDeploymentSelector provides DeploymentSelector interface from SelectorAdapter
func ProvideDeploymentSelector(adapter *interactive.SelectorAdapter) usecase.DeploymentSelector {
	return adapter
}
