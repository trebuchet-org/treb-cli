// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/spf13/viper"
	"github.com/trebuchet-org/treb-cli/internal/adapters/blockchain"
	config2 "github.com/trebuchet-org/treb-cli/internal/adapters/config"
	"github.com/trebuchet-org/treb-cli/internal/adapters/forge"
	"github.com/trebuchet-org/treb-cli/internal/adapters/fs"
	"github.com/trebuchet-org/treb-cli/internal/adapters/interactive"
	"github.com/trebuchet-org/treb-cli/internal/adapters/template"
	"github.com/trebuchet-org/treb-cli/internal/config"
	"github.com/trebuchet-org/treb-cli/internal/usecase"
)

// Injectors from wire.go:

// InitApp creates a fully wired App instance with viper configuration
func InitApp(v *viper.Viper, sink usecase.ProgressSink) (*App, error) {
	runtimeConfig, err := config.Provider(v)
	if err != nil {
		return nil, err
	}
	registryStoreAdapter, err := fs.NewRegistryStoreAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	listDeployments := usecase.NewListDeployments(runtimeConfig, registryStoreAdapter, sink)
	showDeployment := usecase.NewShowDeployment(runtimeConfig, registryStoreAdapter, sink)
	contractIndexerAdapter, err := fs.NewContractIndexerAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	selectorAdapter, err := interactive.NewSelectorAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	resolveContract := usecase.NewResolveContract(runtimeConfig, contractIndexerAdapter, selectorAdapter, sink)
	contractResolver := ProvideContractResolver(resolveContract)
	abiParserAdapter, err := forge.NewABIParserAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	scriptGeneratorAdapter, err := template.NewScriptGeneratorAdapter(runtimeConfig, abiParserAdapter)
	if err != nil {
		return nil, err
	}
	fileWriterAdapter, err := fs.NewFileWriterAdapter(runtimeConfig)
	if err != nil {
		return nil, err
	}
	generateDeploymentScript := usecase.NewGenerateDeploymentScript(runtimeConfig, contractResolver, abiParserAdapter, scriptGeneratorAdapter, fileWriterAdapter, sink)
	networkResolver := config.ProvideNetworkResolver(runtimeConfig)
	networkResolverAdapter := config2.NewNetworkResolverAdapter(networkResolver)
	listNetworks := usecase.NewListNetworks(networkResolverAdapter)
	checkerAdapter := blockchain.NewCheckerAdapter()
	pruneRegistry := usecase.NewPruneRegistry(networkResolverAdapter, checkerAdapter, registryStoreAdapter, sink)
	localConfigStoreAdapter := fs.NewLocalConfigStoreAdapter(runtimeConfig)
	showConfig := usecase.NewShowConfig(localConfigStoreAdapter)
	setConfig := usecase.NewSetConfig(localConfigStoreAdapter)
	removeConfig := usecase.NewRemoveConfig(localConfigStoreAdapter)
	app, err := NewApp(runtimeConfig, listDeployments, showDeployment, generateDeploymentScript, listNetworks, pruneRegistry, showConfig, setConfig, removeConfig)
	if err != nil {
		return nil, err
	}
	return app, nil
}

// wire.go:

// ProvideContractResolver provides ContractResolver interface from ResolveContract
func ProvideContractResolver(uc *usecase.ResolveContract) usecase.ContractResolver {
	return uc
}
