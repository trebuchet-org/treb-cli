# Go CLI Architecture (Cobra + Viper + Wire)

A pragmatic, testable structure for a Go CLI that cleanly separates concerns: **CLI (presentation)**, **use cases (application logic)**, **ports (interfaces)**, **adapters (infrastructure)**, and **domain (types/rules)**—with **Viper** for configuration and **Wire** for compile-time DI.

---

## Goals & Principles

* **Name by domain, not layer.** Avoid “utils/helpers”.
* **One `Config` struct**; deterministic overrides: defaults → file → env → flags.
* **Interfaces live where they’re consumed** (use cases), not next to concretes.
* **Dependency direction:** `cli → usecase → ports → adapters`. Domain is independent.
* **Manual constructors + Wire** to assemble the graph at compile time.
* **No UI in business code.** Use domain-level progress events for long runs.

---

## Folder Structure

```
yourcli/
  cmd/
    yourcli/
      main.go                # binary entrypoint; calls app.InitApp(cfg)
  internal/
    app/
      config.go              # Config struct + validation
      config_load.go         # Viper-based load (json/yaml/env)
      wire.go                # //go:build wireinject: injector spec
      wire_gen.go            # generated by wire (do not edit)
      app.go                 # App struct (aggregates use cases), logging setup
    domain/
      types.go               # core value objects/entities
      errors.go              # sentinel errors, error helpers
    usecase/
      ports.go               # interfaces needed by use cases
      list_things.go         # use case; pure orchestration
      create_thing.go        # another use case
      progress.go            # ProgressEvent + ProgressSink (NOP impl)
    adapters/
      fs/
        store.go             # implements ports using filesystem
      httpapi/
        client.go            # implements ports using HTTP
      db/
        repo.go              # implements ports using DB (optional)
      providers.go           # Wire ProviderSets + bindings
    cli/
      root.go                # Cobra root; flags, global options
      list.go                # subcommand; parses flags → calls use case
      create.go              # subcommand
      render.go              # printers, JSON/text table
      progress_renderer.go   # implements usecase.ProgressSink for CLI
  pkg/                       # optional public API for reuse (stable)
  Makefile
  go.mod
  README.md
```

---

## What Lives Where

### `internal/app`

* **`Config`**: single struct for all configuration.
* **Loading**: Viper merges defaults, config file, env, then flags (bound in `cli`).
* **`App`**: thin composition root holding references to use cases and shared deps.
* **Wire**: provider graph to construct `App` from `Config`.

### `internal/domain`

* Pure types and rules (no IO). Value constructors that enforce invariants.
* Sentinel errors (e.g., `ErrNotFound`) for portable error handling.

### `internal/usecase`

* **Use cases** (application services) named by **intent** (`ListThings`, `CreateThing`).
* Depend on **ports** (interfaces) declared here.
* Accept `context.Context` and **emit `ProgressEvent`** via a `ProgressSink` port for long tasks.
* Return domain results and domain errors—no printing, no `os.Exit`.

### `internal/adapters`

* Concrete implementations of ports: filesystem, HTTP, DB, etc.
* Constructors with explicit dependencies (config, clients, loggers).
* Group **Wire ProviderSets** here and bind concretes to interfaces.

### `internal/cli`

* Cobra commands (`root`, subcommands) parse flags and args.
* Bind flags to `Config` (via pointers or Viper keys), then pass final `Config` to the injector or use cases.
* Rendering only: tables, JSON, spinners/progress. Implements `ProgressSink`.

---

## Config with Viper (JSON/YAML/ENV/Flags)

**`internal/app/config.go`**

```go
type Config struct {
    DataDir    string        `mapstructure:"data_dir"`
    APIBaseURL string        `mapstructure:"api_base_url"`
    Token      string        `mapstructure:"token"`
    Timeout    time.Duration `mapstructure:"timeout"`
}
```

**`internal/app/config_load.go`**

```go
func LoadBaseConfig(configFile string) (Config, error) {
    var cfg Config
    v := viper.New()
    if configFile != "" {
        v.SetConfigFile(configFile)           // supports .json, .yaml, .toml...
    } else {
        v.SetConfigName("config")
        v.AddConfigPath(".")
        v.AddConfigPath("$HOME/.yourcli")
    }

    v.SetDefault("timeout", "5s")
    v.AutomaticEnv()
    _ = v.ReadInConfig() // ignore not-found; still have env/defaults

    if err := v.Unmarshal(&cfg); err != nil { return cfg, err }
    return cfg, nil
}
```

**Binding flags in CLI**:

```go
// internal/cli/root.go
func NewRootCmd(baseCfg app.Config) *cobra.Command {
    cfg := baseCfg // copy for this invocation

    cmd := &cobra.Command{ Use: "yourcli" }
    f := cmd.PersistentFlags()
    f.StringVar(&cfg.DataDir, "data-dir", cfg.DataDir, "Data directory")
    f.StringVar(&cfg.APIBaseURL, "api-base-url", cfg.APIBaseURL, "API base URL")
    f.StringVar(&cfg.Token, "token", cfg.Token, "API token")
    f.DurationVar(&cfg.Timeout, "timeout", cfg.Timeout, "Request timeout")

    cmd.AddCommand(newListCmd(&cfg), newCreateCmd(&cfg))
    return cmd
}
```

---

## Use Cases, Ports, and Progress

**Ports defined at the consumer (usecase):**

```go
// internal/usecase/ports.go
type ThingStore interface {
    List(ctx context.Context, filter string) ([]domain.Thing, error)
    Save(ctx context.Context, t domain.Thing) error
}

type ProgressEvent struct {
    Stage   string
    Current int
    Total   int
    Message string
}
type ProgressSink interface {
    OnProgress(ctx context.Context, e ProgressEvent)
}
type NopProgress struct{}
func (NopProgress) OnProgress(context.Context, ProgressEvent) {}
```

**A use case emitting progress:**

```go
// internal/usecase/list_things.go
type ListParams struct{ Filter string }

type ListThings struct {
    store ThingStore
    sink  ProgressSink
}
func NewListThings(s ThingStore, sink ProgressSink) *ListThings {
    return &ListThings{store: s, sink: sink}
}

func (uc *ListThings) Run(ctx context.Context, p ListParams) ([]domain.Thing, error) {
    items, err := uc.store.List(ctx, p.Filter)
    if err != nil { return nil, err }
    uc.sink.OnProgress(ctx, ProgressEvent{Stage: "fetched", Current: len(items), Total: len(items)})
    // business rules (sort/filter)…
    return items, nil
}
```

---

## Adapters & Wire

**Filesystem adapter providing `ThingStore`:**

```go
// internal/adapters/fs/store.go
type Store struct{ root string }
func NewStore(root string) (*Store, error) { return &Store{root: root}, nil }

// Ensure it implements usecase.ThingStore
var _ usecase.ThingStore = (*Store)(nil)
```

**Provider sets & bindings:**

```go
// internal/adapters/providers.go
var FSSet = wire.NewSet(
    NewStore,
    wire.Bind(new(usecase.ThingStore), new(*fs.Store)),
)
```

**App composition + Wire injector:**

```go
// internal/app/app.go
type App struct {
    ListThings *usecase.ListThings
}

func NewApp(list *usecase.ListThings) (*App, error) { return &App{ListThings: list}, nil }
```

```go
// internal/app/wire.go
//go:build wireinject
package app

import (
    "github.com/google/wire"
    "yourcli/internal/adapters"
    "yourcli/internal/usecase"
)

func InitApp(cfg Config, sink usecase.ProgressSink) (*App, error) {
    wire.Build(
        // pluck fields from cfg for constructors
        wire.FieldsOf(new(Config), "DataDir", "APIBaseURL", "Token", "Timeout"),
        adapters.FSSet,
        // other sets: adapters.HTTPSet, adapters.DBSet, etc.
        func(s usecase.ProgressSink) usecase.ProgressSink { return s }, // pass-through
        usecase.NewListThings,
        NewApp,
    )
    return nil, nil
}
```

Generated with:

```
go install github.com/google/wire/cmd/wire@latest
cd internal/app && wire
```

---

## CLI Commands call Use Cases

```go
// internal/cli/list.go
func newListCmd(cfg *app.Config) *cobra.Command {
    var filter string

    c := &cobra.Command{
        Use:   "list",
        Short: "List things",
        RunE: func(cmd *cobra.Command, _ []string) error {
            // Progress renderer for this invocation (or use NOP for --quiet)
            renderer := &CLIRenderer{Out: cmd.OutOrStdout()}
            a, err := app.InitApp(*cfg, renderer)
            if err != nil { return err }

            items, err := a.ListThings.Run(cmd.Context(), usecase.ListParams{Filter: filter})
            if err != nil { return err }
            return PrintTable(cmd.OutOrStdout(), items)
        },
    }
    c.Flags().StringVar(&filter, "filter", "", "Filter results")
    return c
}
```

**CLI progress renderer (presentation only):**

```go
// internal/cli/progress_renderer.go
type CLIRenderer struct{ Out io.Writer }
func (r *CLIRenderer) OnProgress(_ context.Context, e usecase.ProgressEvent) {
    fmt.Fprintf(r.Out, "[%s] %d/%d %s\n", e.Stage, e.Current, e.Total, e.Message)
}
```

---

## `main.go`

```go
// cmd/yourcli/main.go
func main() {
    baseCfg, err := app.LoadBaseConfig("") // use default search; supports JSON
    if err != nil { fmt.Fprintln(os.Stderr, err); os.Exit(2) }

    root := cli.NewRootCmd(baseCfg)
    if err := root.Execute(); err != nil { os.Exit(1) }
}
```

---

## Testing Strategy

* **Use case tests**: pass fakes for ports and `NopProgress`; test pure behavior.
* **Adapter tests**: temp dirs (`t.TempDir()`), `httptest.Server`, DB containers if needed.
* **CLI tests**: invoke commands with `bytes.Buffer` for stdout/stderr; assert output.
* **Wire-free unit tests**: call constructors directly; reserve Wire for integration tests.

---

## When to Scale Up

* **Many commands** → subpackages per feature under `cli/` and `usecase/`.
* **Complex graphs** → more `ProviderSet`s; consider splitting injectors per binary.
* **Plugins** → add `plugins/` adapter; communicate via exec & JSON for stability.

---

## TL;DR

* Keep **use cases** UI-agnostic; expose **ports** and **ProgressEvent**.
* Use **adapters** to touch the outside world; bind to **ports** via Wire.
* Let **Cobra** own input/parsing and **renderers** own output.
* **Viper** feeds a single `Config` that flags can override.
* **Wire** composes everything at compile time—no runtime container, no globals.

